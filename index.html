<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Net Domestic Migration of Korea</title>        
    <script src="sido.js"></script>
    <script src="sigungu.js"></script>
    <script src="admxy.js"></script>
    <script src="netpopumove.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
 

    <meta name="viewport" content="width=device-width, height=device-height, user-scalable=no" />

    <style type="text/css">

        html {
            min-height: 100% !important;
            width: 100%;
            height: 100%;
        }

        /* border 제거 */
        body {
            margin-left : 0;
            margin-right : 0;
            margin-top : 0;
            margin-bottom : 0;
            border: 0;
            background-color: black;
        }
        .container {
            position: relative;
        }
        div.left_button {
            position: absolute; /* Reposition logo from the natural layout */
            left: 0px;
            top: 0px;
            width: 100px;
            height: 100%;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.0);
        }
        div.main_canvas {
            
            z-index: 1;

        }
        /* canvas를 viewport 크기로 만들기 */
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #text {
            background-color: transparent;  /* needed because webgl-tutoraisl.css sets canvas bg color to white */
            position: absolute;
            left: 0px;
            top: 0px;
            z-index: 10;
            -webkit-text-fill-color: aliceblue;
        }

        .toggleBG{
            background: #68819c;
            width: 90px;
            height: 30px;
            border: 1px solid #eeeeee;
            border-radius: 15px;
            margin-top : 5px;
            margin-bottom : 5px;
        }
        .toggleFG{
            background: #FFFFFF;
            top : 3px;      
            left : 65px;     
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 12px;
            position: relative;
 
            
        }
        .toggleText{
            top : -2px;          

            border: none;           
            position: relative;
            
        }
        .toggleBG1{
            background: #143a5e;
            width: 150px;
            height: 30px;
            border: 1px solid #eeeeee;
            border-radius: 15px;
            margin-top : 5px;
            margin-bottom : 5px;
        }
        .toggleFG1{
            background: #FFFFFF;
            top : 3px;      
            left : 125px;     
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 12px;
            position: relative;            
        }
        .spacer{
            
            height: 13px;


            position: relative;            
        }


    </style>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XG64WBEY3K"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-XG64WBEY3K');
    </script>

    <script type="text/javascript">

        var gl; // A global variable for the WebGL context
      
       
        // 이 코드나 관련된 데이터를 사용하실 경우, 코드에 다음의 주석을 반드시 남겨주시기 바랍니다.
        // source :  https://github.com/vuski/netPopuMoveKorea


        function ShaderVars() {
            var shader;
         
            var zscale;
            var translation;
            var color;
            var tidx;
            var drawRatio;
            var countThreshold;
            var onlyNearOn;
            var groundxy;
            var widReducRatio;
            var sidoFlag;


           ShaderVars.prototype.setUniformLoc =  function () {
                this.translation = gl.getUniformLocation(this.shader, "trans");                
                this.zscale = gl.getUniformLocation(this.shader, "zscale");
                this.color = gl.getUniformLocation(this.shader, "color");
                this.tidx = gl.getUniformLocation(this.shader, "tidx");
                this.drawRatio = gl.getUniformLocation(this.shader, "drawRatio");
                this.countThreshold = gl.getUniformLocation(this.shader, "countThreshold");
                this.onlyNearOn = gl.getUniformLocation(this.shader, "onlyNearOn");
                this.groundxy = gl.getUniformLocation(this.shader, "groundxy");
                this.widReducRatio = gl.getUniformLocation(this.shader, "widReducRatio");
                this.sidoFlag = gl.getUniformLocation(this.shader, "sidoFlag");
            } 
           
            var posAttrLoc; 
            var cntAttrLoc; 
            var scoreAttrLoc; 
            var yearAttrLoc; 
            var indexAttrLoc; 
            var sidoAttrLoc;
            
        }

        function BufferObject() {
            var vbo;            
            var idxbo;
            var numObj;
            var numIndex;
            
        }

        var shaderSigungu;
        var boSigungu;

        var shaderSido;
        var boSido;

        var shaderPopu;
        var boPopu;

        var canvas;
        var textCanvas; 
        var ctx;
        var ctxgl;

        var scrW;
        var scrH;
        var whRatio;
         
        var cenX = 1015470.0;
        var cenY = 1815322.0;
        var zoomR = 20;
        var minX = cenX-10000*zoomR;
        var maxX = cenX+10000*zoomR;
        var minY;    
        var calR;
        var maxY;  
        

        var drag = false;
        var oldx, oldy;
        var dx = 0, dy = 0;
        var mx,my;               


        var helpOn = true;

        var admxy = new Map();

        var thisyear = new Array();
            //= [2001.0, 2002.0, 2003.0, 2004.0, 2005.0, 2006.0, 2007.0, 2008.0, 2009.0, 2010.0,
            //2011.0, 2012.0, 2013.0, 2014.0, 2015.0, 2016.0, 2017.0 ,2018.0, 2019.0, 2020.0];
        var yearIndex = 0;
        var drawRatio = 1.0;
        var countThreshold = 100;
        var sggOn = true;
        var onlyNearOn = 0;
        var widReducRatio = 5.0;
        var popuVec;
        var popuVecIndex =  new Array();
        var mousex, mousey;

        function main() {

            calR = (maxX - minX) / scrW;
            maxY = cenY +(scrH *calR/2);
            minY = cenY -(scrH *calR/2);            
            whRatio = scrW / scrH ; 

            canvas = document.getElementById("glcanvas");
            textCanvas = document.getElementById("text");
            

            gl = initWebGL(canvas);      // Initialize the GL context
            // Only continue if WebGL is available and working
            if (!gl) return;

            console.log(gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE));


            recalculateMaxY();
            
           
            shaderPopu = new ShaderVars();            
            shaderPopu.shader = getShader("popumoveVertex", "popumoveFragment");
            shaderPopu.setUniformLoc();             
            boPopu= new BufferObject(); 
            setPopuData();              
            
            


            //subway station shader
            shaderSigungu = new ShaderVars();            
            shaderSigungu.shader = getShader("mapBorderVertex", "mapBorderFragment");            
            shaderSigungu.setUniformLoc();       
            boSigungu = new BufferObject();      
            setSigunguDataToBuffer();

        
            shaderSido = new ShaderVars();            
            shaderSido.shader = getShader("mapBorderVertex", "mapBorderFragment");
            shaderSido.setUniformLoc();             
            boSido = new BufferObject();          
            setSidoDataToBuffer();
            
            //console.log("셋팅");
            
            resize(gl.canvas);
            
            //알아서 주사율 맞춰서 조정

            textCanvas.addEventListener("mousedown", mouseDown, false);
            textCanvas.addEventListener("mouseup", mouseUp, false);            
            textCanvas.addEventListener("mousemove", mouseMove, false);           
            textCanvas.addEventListener("wheel", mouseWheel, false);     

            //http://bencentra.com/code/2014/12/05/html5-canvas-touch-events.html
            // Set up touch events for mobile, etc
            //textCanvas.addEventListener("touchstart", touchStart, false);
            //textCanvas.addEventListener("touchend", mouseUp, false);            
            //textCanvas.addEventListener("touchmove", mouseMove, false);           
           
/*
            // Prevent scrolling when touching the canvas
            document.body.addEventListener("touchstart", function (e) {
                if (e.target == textCanvas) {
                    e.preventDefault();
                }
            }, false);
            document.body.addEventListener("touchend", function (e) {
                if (e.target == textCanvas) {
                    e.preventDefault();
                }
            }, false);
            document.body.addEventListener("touchmove", function (e) {
                if (e.target == textCanvas) {
                    e.preventDefault();
                }
            }, false);
*/


            window.addEventListener('keydown', keydown);
                
            requestAnimationFrame(render);

        }

        function getToggleBtnState(toggleBtnId){
            const left_px = parseInt( $('#'+toggleBtnId).css('left') );        
            return (left_px > 0)? 1 : 0;
        }

        function render() {

            var sidoFlag = 0;
            for (var i=0 ; i<=16 ; i++) {
                var currentButton = getToggleBtnState("sido"+ i);
                sidoFlag += currentButton << i;
            }
            var currentButton = getToggleBtnState("intraSido"); //시도내이동
            sidoFlag += currentButton << 17;
            var currentButton = getToggleBtnState("interSido"); //시도간이동
            sidoFlag += currentButton << 18;
             //console.log(sidoFlag);

            //console.log("렌더");
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);      // Clear the color as well as the depth buffer.

            resize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            recalculateMaxY();            
            
            var groundx = 0.0;
            var groundy = 0.0;
            if (onlyNearOn==1) {

            }

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.useProgram(shaderSigungu.shader);
            gl.uniform4f(shaderSigungu.translation, cenX, cenY, maxX-minX, whRatio );   
            gl.uniform4f(shaderSigungu.color, 0.3, 0.3, 0.3, 0.9 ); 
            gl.bindBuffer(gl.ARRAY_BUFFER, boSigungu.vbo);  
            gl.vertexAttribPointer(shaderSigungu.posAttrLoc, 2, gl.FLOAT, false, 0, 0);   
            gl.drawArrays(gl.LINES, 0, boSigungu.numObj);

            //gl.lineWidth(50);
            gl.useProgram(shaderSido.shader);
            gl.uniform4f(shaderSido.translation, cenX, cenY, maxX-minX, whRatio );  
            gl.uniform4f(shaderSido.color, 1, 1, 1, 0.9 );  
            gl.bindBuffer(gl.ARRAY_BUFFER, boSido.vbo);
            gl.vertexAttribPointer(shaderSido.posAttrLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.LINES, 0, boSido.numObj);

            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.useProgram(shaderPopu.shader);
            gl.uniform4f(shaderPopu.translation, cenX, cenY, maxX-minX, whRatio );  
            gl.uniform1f(shaderPopu.drawRatio, drawRatio );  
            gl.uniform1i(shaderPopu.countThreshold, countThreshold);  
            gl.uniform1i(shaderPopu.onlyNearOn, onlyNearOn);  
            gl.uniform2f(shaderPopu.groundxy, mx, my);  
            gl.uniform1f(shaderPopu.widReducRatio, widReducRatio);  
            gl.uniform1i(shaderPopu.sidoFlag, sidoFlag);  

            gl.bindBuffer(gl.ARRAY_BUFFER, boPopu.vbo);
            gl.vertexAttribPointer(shaderPopu.posAttrLoc, 4, gl.FLOAT, false, 0, 0);
            gl.vertexAttribPointer(shaderPopu.cntAttrLoc, 1, gl.FLOAT, false, 0, 3 * 4*4* boPopu.numObj);
            gl.vertexAttribPointer(shaderPopu.scoreAttrLoc, 1, gl.FLOAT, false, 0, 3 * 4*5* boPopu.numObj); 
            gl.vertexAttribPointer(shaderPopu.indexAttrLoc, 1, gl.FLOAT, false, 0, 3 * 4*6* boPopu.numObj);
            gl.vertexAttribPointer(shaderPopu.sidoAttrLoc, 1, gl.FLOAT, false, 0, 3 * 4*7* boPopu.numObj);

            for (var i=0 ; i<63 ; i++) {
                gl.uniform1i(shaderPopu.tidx, i); 
                gl.drawArrays(gl.TRIANGLES, thisyear[yearIndex], thisyear[yearIndex+1] - thisyear[yearIndex]);//boPopu.numObj);
            }
            



            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);    


            //주변만 표시할때는 숫자도 표시한다.
            if (onlyNearOn==1) {

                ctx.beginPath();
                ctx.arc(mousex, mousey, (20/Math.sqrt(zoomR)), 0, Math.PI*2, true);
                ctx.fillStyle = "rgba(255,255,255,0.1)"
                ctx.fill();
                ctx.closePath();

                ctx.textAlign = 'center';
                ctx.textBaseline = "middle";
                ctx.font = "bold " +(30/Math.sqrt(zoomR)) + "px '맑은 고딕'";        
                ctx.fillStyle = "rgba(200,200,200,1)";
         
                var radFrom = (Math.PI / 180.0) * 45.0;  //150
                var radTo = (Math.PI / 180.0) * 315.0;   //270
                var scaled = 4.0;
                var drawMargin = 1000.0;
                var splitPoints = 30.0;
                var lineWidth = 1000.0;

                for (var i=popuVecIndex[yearIndex]; i < popuVecIndex[yearIndex+1] ; i++) {

                    var pv = popuVec[i];

                    var orix = (mx - pv[0]);
                    var oriy = (my - pv[1]);
                    var desx = (mx - pv[2]);
                    var desy = (my - pv[3]);

                    var isNear = (orix*orix + oriy * oriy) < 4000000.0 || 
                        (desx * desx + desy * desy) < 4000000.0;

                    if (isNear && pv[4]>=countThreshold) { //가깝고 표출수치 이상이면

                        var ori = [pv[0], pv[1]];
                        var des = [pv[2], pv[3]];
                        var distOriDes = Math.sqrt( (ori[0] - des[0]) * (ori[0] - des[0]) +
                                     (ori[1] - des[1]) *  (ori[1] - des[1]));

                        var oriR = rotate([des[0] - ori[0], des[1] - ori[1]], radFrom);
                        var desR = rotate([ori[0] - des[0], ori[1] - des[1]], radTo);

                        var ori_ = [oriR[0]/scaled + ori[0], oriR[1]/scaled + ori[1]];
                        var des_ = [desR[0]/scaled + des[0], desR[1]/scaled + des[1]];
                        var cc = [3.0 * (ori_[0] - ori[0]), 3.0 * (ori_[1] - ori[1])];
                        var bb = [3.0 * (des_[0] - ori_[0]) - cc[0], 3.0 * (des_[1] - ori_[1]) - cc[1]];
                        var aa = [des[0] - ori[0] - cc[0] - bb[0], des[1] - ori[1] - cc[1] - bb[1]];

                        //var ori_ = rotate(des.xy-ori.xy, radFrom)/scaled + ori.xy;
                        //var des_ = rotate(ori.xy-des.xy, radTo)/scaled + des.xy;
                        //var cc = 3.0 * (ori_ - ori);
                        //var bb = 3.0 * (des_ - ori_) - cc;
                        //var aa = des - ori - cc - bb;

                        var drawLimitPoint = drawRatio * (1.0 - drawMargin /distOriDes);           

                        var value = Math.sqrt(pv[4] / 14518.0); 
                        var width = value * lineWidth; //나중에 곱하는 수치가 두께

                        var startPoint = 0.0;
                        var endPoint =  drawLimitPoint * (1.0 -  drawRatio * 2.0* width /distOriDes);
                        var dt = (endPoint-startPoint)/ splitPoints;

                        var t = startPoint + 20.0 * dt;
                        var tSquared = t * t;
                        var tCubed = tSquared * t;
                        var p0 = [(aa[0]* tCubed) + (bb[0]* tSquared) + (cc[0] * t) + ori[0],
                                (aa[1]* tCubed) + (bb[1]* tSquared) + (cc[1] * t) + ori[1]];

                         
                        ctx.fillText(pv[4], 
                            (p0[0]- cenX)/(maxX-minX)*(scrW/2)+(scrW/2),
                            (p0[1]- cenY)/(maxX-minX)*(scrH/2*whRatio)*-1+scrH/2);


                    }
                }
            }



            if (helpOn) {

                ctx.textAlign = 'center';

                ctx.textBaseline = "top";

                
                ctx.font = "bold 20px '맑은 고딕'";        
                ctx.fillStyle = "rgba(200,200,200,1)";
                ctx.fillText("시군구간 인구 순이동 ver 1.11", scrW/2,scrH-40);
                //2021.04.28 ver 1.1 시도 토글버튼 추가
                //2021.04.28 ver 1.11 시도 토글버튼 추가

                ctx.font = "bold 80px '맑은 고딕'";  
                ctx.fillStyle = "rgba(255,255,255,1)";
                ctx.fillText((yearIndex+2001)+"년", scrW/2,20);

                ctx.font = "25px '맑은 고딕'";  
                ctx.fillStyle = "rgba(200,200,200,1)";
                ctx.fillText(countThreshold+"명 이상 순이동만 표현", scrW/2,100);

                if (onlyNearOn==1) {
                    ctx.font = "25px '맑은 고딕'";  
                    ctx.fillStyle = "rgba(200,200,200,1)";
                    ctx.fillText("마우스 주변 시군구만 표현", scrW/2,130);
                } 


                ctx.textBaseline = "bottom";
                ctx.textAlign = 'left';
                var topH = 340;

                ctx.font = "15px '맑은 고딕'";
                ctx.fillStyle = "rgba(255,255,255,1)";
                ctx.fillText("*. 휴대폰 조작은 구현되어 있지 않습니다. pc로 접속해주세요",15, scrH-topH); 

                ctx.font = "15px '맑은 고딕'";
                ctx.fillStyle = "rgba(200,200,200,1)";
                ctx.fillText("*. 키보드 h 키를 눌러서 아래 설명을 숨길 수 있습니다.",15, scrH-topH+20); 

                ctx.font = "15px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("*. 통계청 마이크로데이터 인구이동 데이터를 사용하여 연도별로 시군구간 순이동을 계산하였습니다." ,15, scrH-topH+40); 

                ctx.font = "15px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("*. 순이동 중 40세 미만이 우세하면 푸른색으로, 40세 이상이 우세하면 붉은색 화살표로 표시하였습니다." ,15, scrH-topH+60);


                ctx.font = "20px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("마우스 휠 / 왼쪽버튼 : zoom & pan",15, scrH-topH+120); 

                ctx.font = "20px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("z/x : 기준연도 변경" ,15, scrH-topH+150); 

                ctx.font = "20px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("↑ ↓ : 순이동 제한선 변경" ,15, scrH-topH+180); 

                ctx.font = "20px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("← → : 이동선 길이 변경" ,15, scrH-topH+210); 

                ctx.font = "20px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("c : 시군구 이름 on/off" ,15, scrH-topH+240); 

                ctx.font = "20px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("v : 마우스 주변 이동만 보기 on/off" ,15, scrH-topH+270); 

                ctx.font = "20px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("a/s : 이동선 두께 감쇄율 조정" ,15, scrH-topH+300); 


                ctx.font = "17px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,150,150,1)";
                ctx.fillText("https://www.vw-lab.com/" ,15, scrH-topH+330); 


            }
            else {

                ctx.textAlign = 'center';
                ctx.textBaseline = "top";

                ctx.font = "bold 80px '맑은 고딕'";  
                ctx.fillStyle = "rgba(255,255,255,1)";
                ctx.fillText((yearIndex+2001)+"년", scrW/2,20);

                ctx.font = "25px '맑은 고딕'";  
                ctx.fillStyle = "rgba(200,200,200,1)";
                ctx.fillText(countThreshold+"명 이상 순이동만 표현", scrW/2,100);

                if (onlyNearOn==1) {
                    ctx.font = "25px '맑은 고딕'";  
                    ctx.fillStyle = "rgba(200,200,200,1)";
                    ctx.fillText("마우스 주변 시군구만 표현", scrW/2,130);
                } 

                ctx.textBaseline = "bottom";
                ctx.textAlign = 'left';
                ctx.font = "15px '맑은 고딕'";
                ctx.fillStyle = "rgba(150,200,10,1)";
                ctx.fillText("'h' key : 도움말",15, scrH-20); 

            
            }
        
            if (sggOn) {
                ctx.textAlign = 'center';
                ctx.textBaseline = "middle";
                ctx.font = (30/Math.sqrt(zoomR))+"px '맑은 고딕'";        
                ctx.fillStyle = "rgba(110,100,80,0.7)";

                for (var i=0 ; i<sggCoord.length ; i++ ) {
                    if (sggCoord[i][4]==1)
                        ctx.fillText(sggCoord[i][3],
                            (sggCoord[i][1]-cenX)/(maxX-minX)*(scrW/2)+(scrW/2),
                            (sggCoord[i][2]-cenY)/(maxX-minX)*(scrH/2*whRatio)*-1+scrH/2);

                }
            }
            //requestAnimationFrame(render);
        }




        function setSigunguDataToBuffer() {

            var pos = new Array();

            for (var i=0 ; i < sigungu.features.length ; i++) {

                var coordArray = sigungu.features[i]["geometry"]["coordinates"];

                for (var j=0 ; j < coordArray.length-1 ; j++) {
                    
                    var coord0 = coordArray[j];
                    var coord1 = coordArray[j+1];
                    
                    pos.push(coord0[0]);
                    pos.push(coord0[1]);
                    pos.push(coord1[0]);
                    pos.push(coord1[1]);
                }

            }            

            boSigungu.numObj = pos.length / 2;

            boSigungu.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, boSigungu.vbo);

            gl.bufferData(gl.ARRAY_BUFFER, 4*2*boSigungu.numObj , gl.STATIC_DRAW);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(pos));

            shaderSigungu.posAttrLoc = gl.getAttribLocation(shaderSigungu.shader, "pos");                   
            gl.enableVertexAttribArray(shaderSigungu.posAttrLoc);    
           
            

        }

        function setSidoDataToBuffer() {

            var pos = new Array();

            for (var i=0 ; i < sido.features.length ; i++) {

                var coordArray = sido.features[i]["geometry"]["coordinates"];

                for (var j=0 ; j < coordArray.length-1 ; j++) {
                    
                    var coord0 = coordArray[j];
                    var coord1 = coordArray[j+1];
                    
                    pos.push(coord0[0]);
                    pos.push(coord0[1]);
                    pos.push(coord1[0]);
                    pos.push(coord1[1]);
                }

            }            

            boSido.numObj = pos.length / 2;

            boSido.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, boSido.vbo);

            gl.bufferData(gl.ARRAY_BUFFER, 4*2*boSido.numObj , gl.STATIC_DRAW);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(pos));

            shaderSido.posAttrLoc = gl.getAttribLocation(shaderSido.shader, "pos");      
            gl.enableVertexAttribArray(shaderSido.posAttrLoc);   
           
            

        }
      
        function initWebGL(canvas) {
            gl = null;

            try {
                // Try to grab the standard context. If it fails, fallback to experimental.
                gl = canvas.getContext("webgl")|| canvas.getContext("experimental-webgl");
            }
            catch (e) { }

            // If we don't have a GL context, give up now
            if (!gl) {
                alert("Unable to initialize WebGL. Your browser may not support it.");
                gl = null;
            }


            resize(gl.canvas);
            gl.viewport(0, 0, scrW, scrH);
            gl.clearColor(0.0, 0.0, 0.0, 1.0); 
            gl.enable(gl.DEPTH_TEST);  
            gl.depthFunc(gl.LEQUAL); 
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.getExtension('OES_standard_derivatives');

            //console.log(gl.getParameter(gl.SAMPLE_COVERAGE_VALUE));  // 0.5
            //console.log(gl.getParameter(gl.SAMPLE_COVERAGE_INVERT)); // false
            //gl.enable(gl.SAMPLE_COVERAGE);
            //gl.sampleCoverage(1, false);
            
            
            //gl.getExtension('OES_element_index_uint');
            return gl;
        }

        function getShader(vertexName, fragmentName) {

            var vertexShaderSource = document.getElementById(vertexName).text;
            var fragmentShaderSource = document.getElementById(fragmentName).text;

            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

            gl.shaderSource(vertexShader, vertexShaderSource);
            gl.shaderSource(fragmentShader, fragmentShaderSource);

            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                alert("Error compiling vertex shader : " + gl.getShaderInfoLog(vertexShader));                    
                gl.deleteShader(vertexShader);
                return null;
            }

            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                alert("Error compiling fragment shader : " + gl.getShaderInfoLog(fragmentShader));                    
                gl.deleteShader(fragmentShader);
                return null;
            }

            var shaderProgram = gl.createProgram();

            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);

            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Failed to link shaders");                   
                gl.deleteProgram(shaderProgram);
                return null;
            }
            return shaderProgram;
        }


        function setPopuData() {

            //시군구 코드를 map에 넣는다.
            for (var i=0 ; i < sggCoord.length ; i++) {

                var sl = sggCoord[i];
                admxy.set(sl[0], [sl[1], sl[2]]);
            }

            //console.log(admxy.get(11200)[0]);
            popuVec = new Array(popuRaw.length * 5); // cpu 계산용
            

            var pos = new Array(popuRaw.length * 4 * 3);
            //var year = new Array(popuRaw.length * 3);
            var cnt = new Array(popuRaw.length* 3);
            var score = new Array(popuRaw.length* 3);
            var triangleIndex = new Array(popuRaw.length * 3);
            var sidoIndex = new Array(popuRaw.length * 3);

            var sidomap = new Map();
            sidomap.set(11,0); //서울
            sidomap.set(26,1); //부산
            sidomap.set(27,2); //대구
            sidomap.set(28,3); //인천
            sidomap.set(29,4); //광주
            sidomap.set(30,5); //대전
            sidomap.set(31,6); //울산
            sidomap.set(36,7); //세종
            sidomap.set(41,8); //경기
            sidomap.set(42,9); //강원
            sidomap.set(43,10); //충북
            sidomap.set(44,11); //충남
            sidomap.set(45,12); //전북
            sidomap.set(46,13); //전남
            sidomap.set(47,14); //경북
            sidomap.set(48,15); //경남
            sidomap.set(49,16); //제주
            sidomap.set(50,16); //제주



            var idx = [0.0, 1.0, 2.0];
            var yearCheck = -1;

            for (var i=0 ; i<popuRaw.length ; i++) {

                var sl = popuRaw[i];
                var ori = admxy.get(sl[1]);
                var des = admxy.get(sl[2]);
                var oriSido = sidomap.get(parseInt(sl[1]/1000));
                var desSido = sidomap.get(parseInt(sl[2]/1000));
                var odCode = oriSido * 100 + desSido;

                if (yearCheck != sl[0]) {
                    thisyear.push(i*3);
                    popuVecIndex.push(i); // cpu 계산용
                    yearCheck = sl[0];
                }
                popuVec[i] = [ori[0], ori[1], des[0], des[1], sl[3]]; // cpu 계산용

                for (var j=0 ; j<3 ; j++) {
                    pos[(i * 3 + j) * 4 + 0] = ori[0];
                    pos[(i * 3 + j) * 4 + 1] = ori[1];
                    pos[(i * 3 + j) * 4 + 2] = des[0];
                    pos[(i * 3 + j) * 4 + 3] = des[1];

                    //year[i * 3 + j] = sl[0]+2000.0; //연도
                    cnt[i * 3 + j] = sl[3];
                    score[i * 3 + j] = sl[4];
                    triangleIndex[i * 3 + j] = idx[j];
                    sidoIndex[i * 3 + j] = odCode;
                }
            }
            thisyear.push(popuRaw.length*3);
            popuVecIndex.push(popuRaw.length); // cpu 계산용

            boPopu.numObj = popuRaw.length*3;
            boPopu.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, boPopu.vbo);

            gl.bufferData(gl.ARRAY_BUFFER, 3* 4 *8*boPopu.numObj , gl.STATIC_DRAW);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(pos));
            gl.bufferSubData(gl.ARRAY_BUFFER, 3 * 4*4* boPopu.numObj, new Float32Array(cnt));
            gl.bufferSubData(gl.ARRAY_BUFFER, 3 * 4*5* boPopu.numObj, new Float32Array(score));
            gl.bufferSubData(gl.ARRAY_BUFFER, 3 * 4*6* boPopu.numObj, new Float32Array(triangleIndex));
            gl.bufferSubData(gl.ARRAY_BUFFER, 3 * 4*7* boPopu.numObj, new Float32Array(sidoIndex));

            shaderPopu.posAttrLoc = gl.getAttribLocation(shaderPopu.shader, "pos"); 
            shaderPopu.cntAttrLoc = gl.getAttribLocation(shaderPopu.shader, "cnt"); 
            shaderPopu.scoreAttrLoc = gl.getAttribLocation(shaderPopu.shader, "score"); 
            shaderPopu.indexAttrLoc = gl.getAttribLocation(shaderPopu.shader, "index");            
            shaderPopu.sidoAttrLoc = gl.getAttribLocation(shaderPopu.shader, "sido");  

            gl.enableVertexAttribArray(shaderPopu.posAttrLoc);   
            gl.enableVertexAttribArray(shaderPopu.cntAttrLoc);   
            gl.enableVertexAttribArray(shaderPopu.scoreAttrLoc);  
            gl.enableVertexAttribArray(shaderPopu.indexAttrLoc);  
            gl.enableVertexAttribArray(shaderPopu.sidoAttrLoc);  

     
        }

        function resize(canvas) {
            // 브라우저에서 canvas가 표시되는 크기 탐색
            var displayWidth = canvas.clientWidth;
            var displayHeight = canvas.clientHeight;

            // canvas가 같은 크기가 아닐 때 확인
            if (canvas.width != displayWidth ||
                canvas.height != displayHeight) {

                // canvas를 동일한 크기로 수정
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                textCanvas.width = displayWidth;
                textCanvas.height = displayHeight;
            }
            ctx = textCanvas.getContext("2d");
            ctxgl = canvas.getContext("2d");
            

            
        }

        function recalculateMaxY() {

            scrW = canvas.width;
            scrH = canvas.height;
            minX = cenX-10000*zoomR;
            maxX = cenX+10000*zoomR;
            calR = (maxX - minX) / scrW;
            maxY = cenY +(scrH *calR/2);
            minY = cenY -(scrH *calR/2);            
            whRatio = scrW / scrH ;            
            //console.log(scrW+","+scrH+","+cenX+","+cenY+","+calR+","+whRatio);
        }

        
        //justmove
        function mouseMove(e) {
            
            mousex = e.pageX;
            mousey = e.pageY;

            if (drag) { // 드래그하면 화면 이동
                //console.log("mousedrag");
                //console.log(e.pageX+","+e.pageY);
                dx = (e.pageX - oldx)*calR*2;
                dy = (e.pageY - oldy)*calR*2;
                cenX = cenX - dx;
                cenY = cenY + dy;               
                //console.log(dx*calR +","+dy*calR);
                oldx = e.pageX, oldy = e.pageY;
                e.preventDefault();
            } else {  //그냥 움직일때는 최단경로 찾는다
                //console.log("mousemove");
                recalculateMaxY();
                mx = (e.pageX-scrW/2)/(scrW/2)*(maxX-minX)+cenX;
                my = -(e.pageY-scrH/2)/(scrH/2)/whRatio*(maxX-minX)+cenY;
                //console.log(mx+","+my);               
            }
            requestAnimationFrame(render);
            //console.log(e.pageX +"." + e.pageY);
            //console.log(1);
            //console.log(cenX +"." +cenY);
        }



        function mouseDown(e) {
            
            if (e.button==0) {  //휠클릭
                //console.log("mouseDown");
                drag = true;
                oldx = e.pageX, oldy = e.pageY;
            } else if (e.button==0) {  //왼쪽 클릭
               
            }
           
            e.preventDefault();
            requestAnimationFrame(render);
            return false;
        }

        function mouseUp(e) {
            drag = false;           
            requestAnimationFrame(render);
        }

        function mouseWheel(e) {

            var zoomRCheck = zoomR * ( e.deltaY>0? 1+0.3*e.deltaY/100 : 1+0.2307692*e.deltaY/100);
            if (zoomRCheck < 0.1 || zoomRCheck > 35.0) return;               
           
            zoomR = zoomRCheck;
            cenX -= e.deltaY>0? (maxX-minX)*(e.pageX-scrW/2)/(scrW/2)*0.3*e.deltaY/100
                                : (maxX-minX)*(e.pageX-scrW/2)/(scrW/2)*0.2307692*e.deltaY/100;
            cenY += e.deltaY>0? (maxX-minX)/whRatio*(e.pageY-scrH/2)/(scrH/2)*0.3*e.deltaY/100
                                : (maxX-minX)/whRatio*(e.pageY-scrH/2)/(scrH/2)*0.2307692*e.deltaY/100;     
           
            //console.log(e.deltaX+","+e.deltaY);
            requestAnimationFrame(render);
        }
        
        function touchStart(e) {
            //console.log("mouseDown");
            drag = true;
            oldx = e.pageX, oldy = e.pageY;
            e.preventDefault();
            requestAnimationFrame(render);
            return false;
        }
        function keydown(e) {

            //console.log("keyCode :"+e.keyCode);
            switch(e.keyCode) {

            case 37: //left arrow
                                        
                drawRatio -= 0.01;
                if (drawRatio<0.01) drawRatio = 0.01;

                break;
            case 39: //right arrow
                drawRatio += 0.01;
                if (drawRatio>1.0) drawRatio = 1.0;            
 
                break;

            case 38: //up arrow
                                        
                countThreshold++;
                if (countThreshold>1000) countThreshold = 1000;

                break;
            case 40: //down arrow
                countThreshold--;
                if (countThreshold<0) countThreshold = 0;            
 
                break;

            case 88: //+
                yearIndex++;
                if (yearIndex==21) yearIndex = 0;
                //console.log( (yearIndex+2001));
                break;

            case 90: //-
                yearIndex--;
                if (yearIndex==-1) yearIndex = 20;        
                //console.log( (yearIndex+2001));
                break;
            case 67: //c
                sggOn = !sggOn;                
                break;
            case 86: //v
                if (onlyNearOn==0)  onlyNearOn=1;     
                else onlyNearOn=0;
                break;
            case 65: //a
                widReducRatio -= 0.5;
                if (widReducRatio<0.5) widReducRatio = 0.5;
                console.log("a");
                break;
            case 83: //s
                widReducRatio += 0.5;
                if (widReducRatio>20) widReducRatio = 20.0;   
                break;
            case 72: //help
                    helpOn = !helpOn;
                break;
            }
            requestAnimationFrame(render);
            e.preventDefault();

        }

       
        

        function normalize(ox,oy, x,y) {

            var dist = Math.sqrt( (x-ox) *(x-ox) + (y-oy)*(y-oy) );
            return  [(x-ox) /dist , (y-oy)/dist];

        }

        function normalize0(v) {

            var len = Math.sqrt( v[0] *v[0] + v[1]*v[1] );
            return  [v[0] /len , v[1]/len];

        }

        function len(v) {
            return Math.sqrt( v[0] *v[0] + v[1]*v[1] );
        }

        function rotate(normal, theta) {
            //var theta = Math.PI * (degree);
            var sinT = Math.sin(theta);
            var cosT = Math.cos(theta);
            return [normal[0]*cosT-normal[1]*sinT, normal[0]*sinT+normal[1]*cosT]; 
        }

        function dotVectors(v1, v2) {
            return (v1[0]*v2[0] + v1[1]*v2[1]);
        }

        //https://dororongju.tistory.com/110 참고
        $(document).on('click', '.toggleBG', function () {
            var toggleBG = $(this);
            var toggleFG = $(this).find('.toggleFG');
            var left = toggleFG.css('left');
            if(left == '65px') {
                toggleBG.css('background', '#333333');
                toggleActionStart(toggleFG, 'TO_LEFT', 65);               
            }else if(left == '0px') {
                toggleBG.css('background', '#68819c');
                toggleActionStart(toggleFG, 'TO_RIGHT', 65);
            }
           
        });
        $(document).on('click', '.toggleBG1', function () {
            var toggleBG = $(this);
            var toggleFG = $(this).find('.toggleFG1');
            var left = toggleFG.css('left');
            if(left == '125px') {
                toggleBG.css('background', '#333333');
                toggleActionStart(toggleFG, 'TO_LEFT', 125);               
            }else if(left == '0px') {
                toggleBG.css('background', '#143a5e');
                toggleActionStart(toggleFG, 'TO_RIGHT', 125);
            }
           
        });
 
        // 토글 버튼 이동 모션 함수
        function toggleActionStart(toggleBtn, LR, leftMargin) {
            // 0.01초 단위로 실행
            var intervalID = setInterval(
                function() {
                    // 버튼 이동
                    var left = parseInt(toggleBtn.css('left'));
                    left += (LR == 'TO_RIGHT') ? 5 : -5;
                    if(left >= 0 && left <= leftMargin) {
                        left += 'px';
                        toggleBtn.css('left', left);
                        requestAnimationFrame(render);
                    }                    
                }, 5);
            setTimeout(function(){
                clearInterval(intervalID);
            }, 201);  
        }

    </script>


    <script id="popumoveVertex" type="notjs">
        #define M_PI 3.14159265358979323846
        precision highp float;

        attribute vec4 pos;
        attribute float cnt;
        attribute float score;
        attribute float index;
        attribute float sido;

        uniform int tidx;
        uniform vec4 trans;
        uniform float drawRatio;
        uniform int countThreshold;
        uniform int onlyNearOn;
        uniform vec2 groundxy;
        uniform float widReducRatio;
        uniform int sidoFlag;


        varying vec4 color;
        varying vec2 texValue;
        varying float isDiscard;


        float lineWidth = 1000.0;
        float drawMargin = 1000.0;
        float splitPoints = 30.0;

        vec2 rotate(vec2 a, float t) {

            float cost = cos(t);
            float sint = sin(t);
            float x = cost*a.x-sint*a.y;
            float y = sint*a.x+cost*a.y;
            return vec2(x,y); 
        }


        float getAngle(vec2 a, vec2 b) {

            float under = (length(a) * length(b));
            float acosT = acos(dot(a, b) / under);
            float upper = a.x*b.y - a.y*b.x;
            float asinT = asin(upper / under);
            if (asinT > 0.0) acosT = M_PI * 2.0 - acosT;
            if (acosT != acosT)
            {
                if (dot(a, b) > 0.0) return 0.0;
                else return M_PI;
            }
            return acosT;
        }

        vec2 calculatePL(vec2 v12, float angle1, float width, float t, float endPoint) {


            float powv = (onlyNearOn==1)? 1.0 : widReducRatio;
            float widthMore = (onlyNearOn==1)? 300.0 : 0.0;
            vec2 p0l = rotate(v12,angle1/2.0)* (width+widthMore) * pow(t/endPoint,powv);
            p0l = p0l * (0.2 + 0.8 * drawRatio);

            return p0l;

        }

        vec4 middleColorBlue = vec4(0.0 / 255.0, 116.0 / 255.0, 231.0 / 255.0, 1.0);
        vec4 middleColorRed = vec4(239.0 / 255.0, 0.0 / 255.0, 105.0 / 255.0, 1.0);
        vec4 middleColorMiddle = vec4(43.0 / 255.0, 26.0 / 255.0, 27.0 / 255.0, 1.0);
        float pow_ = 0.1;
        

        void main() {           
            
           

            //int sidoFlag = 0x100000;

            //색상 결정
            vec4 colorOri, colorDes;          
            if (score<0.0) { //score가 음수면, 출발지가 고령화되는 이동임
		
                float colorC = pow( abs(float(score)/27217.0), pow_);
                colorOri =  mix(middleColorMiddle, middleColorRed, colorC);
                colorDes =  mix(middleColorMiddle, middleColorBlue, colorC);
            }
            else { //score가 음수면, 도착지가 고령화되는 이동임
                float colorC = pow( abs(float(score)/-202810.0), pow_);
                colorOri = mix(middleColorMiddle, middleColorBlue, colorC);
                colorDes = mix(middleColorMiddle, middleColorRed, colorC);        
            }


            vec2 posf;

            //인덱스에 따라 순번 부여
            //if (index==0.0) posf = pos.xy  + vec2(float(tidx)*100.0,0.0);
            //else if (index==1.0) posf = pos.zw;
            //else posf = pos.zw + vec2(cnt+float(tidx*10),0.0);

            vec2 ori = pos.xy;	
            vec2 des = pos.zw;
            
            if (onlyNearOn==1) {
                isDiscard = 
                    (distance(ori, groundxy)<2000.0 ||
                     distance(des, groundxy)<2000.0) && 
                     cnt>=float(countThreshold)?
                     1.0 : -1.0;
            } else {
                float bool01 = cnt>=float(countThreshold)? 1.0 : -1.0;
                int oricd = int(sido/100.0);
                int descd = int(sido) - int(sido/100.0)*100;
                int oribit = 1;
                //webgl1 은 배열값을 가져오는 것도 안되고, switch도 안됨
                if (oricd==0) oribit = 1;
                else if (oricd==1) oribit = 2;
                else if (oricd==2) oribit = 4;
                else if (oricd==3) oribit = 8;
                else if (oricd==4) oribit = 16;
                else if (oricd==5) oribit = 32;
                else if (oricd==6) oribit = 64;
                else if (oricd==7) oribit = 128;
                else if (oricd==8) oribit = 256;
                else if (oricd==9) oribit = 512;
                else if (oricd==10) oribit = 1024;
                else if (oricd==11) oribit = 2048;
                else if (oricd==12) oribit = 4096;
                else if (oricd==13) oribit = 8192;
                else if (oricd==14) oribit = 16384;
                else if (oricd==15) oribit = 32768;
                else if (oricd==16) oribit = 65536;

                int desbit = 1;
                if (descd==0) desbit = 1;
                else if (descd==1) desbit = 2;
                else if (descd==2) desbit = 4;
                else if (descd==3) desbit = 8;
                else if (descd==4) desbit = 16;
                else if (descd==5) desbit = 32;
                else if (descd==6) desbit = 64;
                else if (descd==7) desbit = 128;
                else if (descd==8) desbit = 256;
                else if (descd==9) desbit = 512;
                else if (descd==10) desbit = 1024;
                else if (descd==11) desbit = 2048;
                else if (descd==12) desbit = 4096;
                else if (descd==13) desbit = 8192;
                else if (descd==14) desbit = 16384;
                else if (descd==15) desbit = 32768;
                else if (descd==16) desbit = 65536;

                         
                int temp0 = sidoFlag / oribit;
                int temp1 = temp0/2 * 2;
                if (temp0==temp1) bool01 = -1.0;//같지 않으면 1의 자리가 1임
             
                    
                int temp2 = sidoFlag / desbit;
                int temp3 = temp2/2 * 2;
                if (temp2==temp3) bool01 = -1.0;//같지 않으면 1의 자리가 1임
                
                //시도내이동
                int temp4 = sidoFlag / 131072; //2^17
                int temp5 = temp4/2 * 2;
                if (temp4==temp5 && oricd==descd) bool01 = -1.0;


                //시도간이동
                int temp6 = sidoFlag / 262144; //2^18
                int temp7 = temp6/2 * 2;
                if (temp6==temp7 && oricd!=descd) bool01 = -1.0;

                isDiscard = bool01;
            }
            


            vec2 oridesNormal = normalize(des-ori);
            float distOriDes = distance(ori, des);
            
            float radFrom = (M_PI / 180.0) * 45.0;  //150
            float radTo = (M_PI / 180.0) * 315.0;   //270
            float scaled = 4.0;
            vec2 ori_ = rotate(des.xy-ori.xy, radFrom)/scaled + ori.xy;
            vec2 des_ = rotate(ori.xy-des.xy, radTo)/scaled + des.xy;
            vec2 cc = 3.0 * (ori_ - ori);
            vec2 bb = 3.0 * (des_ - ori_) - cc;
            vec2 aa = des - ori - cc - bb;
            float t, tSquared, tCubed;
            
            

            float drawLimitPoint = drawRatio * (1.0 - drawMargin /distOriDes);
           
            float endPoint;
            float startPoint;

            float value = sqrt(cnt / 14518.0); 
            float width = value * lineWidth; //나중에 곱하는 수치가 두께

            startPoint = 0.0;
			endPoint =  drawLimitPoint * (1.0 -  drawRatio * 2.0* width /distOriDes);
            //if (endPoint<0.0) endPoint = 0.0;
			float dt = (endPoint-startPoint)/ splitPoints;
            //float endPoint5pow = pow(endPoint,5.0);
     
            vec2 p_1, p0, p1, p2;
            vec2 v10, v12;
            

            if (tidx >= 58 && tidx <=62) { //맨 끝 화살표부분

                t = startPoint + float(56/2) * dt; 
                tSquared = t * t;
                tCubed = tSquared * t;
                p0 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;


                t += dt ;  //58을 중심으로.
                tSquared = t * t;
                tCubed = tSquared * t;
                p1 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
                        

                t += dt; //endpoint 보다 dt만큼 더 나간 점이다.
                tSquared = t * t;
                tCubed = tSquared * t;
                //p2는 그리지 않았으나, 한 단계 앞의 점임
                p2 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;


                    
                v10 = normalize(p0-p1);
                v12 = normalize(p2-p1);
                float angle1 =getAngle(v12,v10); //두 직선이 이루는 각

                vec2 p0l = calculatePL(v12, angle1, width, t, endPoint);        
                vec2 p0lf = p1 +p0l;
                vec2 p0rf = p1 -p0l;
                color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint) ,1.0);

                t = drawLimitPoint * (1.2 - drawRatio * 0.2);
                tSquared = t * t;
                tCubed = tSquared * t;
                vec2 pf = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;


                vec2 arrowNormal = normalize(pf-p1); //pf는 최종 도달점. p1은 endpoint 점
                vec2 arrow = pf;

                //오목하게 들어간 부분
                vec2 p0larrow =	p1+ arrowNormal * width * drawRatio * 0.9 +0.3*p0l ;
                vec2 p0rarrow = p1+ arrowNormal * width * drawRatio* 0.9 -0.3*p0l ;
                
                //날개 끝
                vec2 p0larrow2 = p1+ arrowNormal * drawRatio* width * 0.2 +p0l*1.1;
                vec2 p0rarrow2 = p1+ arrowNormal * drawRatio* width * 0.2 -p0l*1.1;

                	
                texValue =  vec2(11.0,0);
                vec2 position;

                if (tidx==58) {
                    if (index==0.0) position = (p0lf-trans.xy)/trans.z ;
                    else if (index==1.0) position = (p0rf-trans.xy)/trans.z ; 
                    else position = (p0larrow-trans.xy)/trans.z ;  

                } else if (tidx==59) {
                    if (index==0.0) position = (p0rf-trans.xy)/trans.z ;
                    else if (index==1.0) position = (p0larrow-trans.xy)/trans.z ; 
                    else position = (p0rarrow-trans.xy)/trans.z ;  

                }  else if (tidx==60) {
                    if (index==0.0) position = (p0larrow-trans.xy)/trans.z ;
                    else if (index==1.0) position = (p0rarrow-trans.xy)/trans.z ; 
                    else position = (arrow-trans.xy)/trans.z ;  

                }  else if (tidx==61) {
                    if (index==0.0) position = (p0rarrow-trans.xy)/trans.z ;
                    else if (index==1.0) position = (arrow-trans.xy)/trans.z ; 
                    else position = (p0rarrow2-trans.xy)/trans.z ;  

                }  else if (tidx==62) {
                    if (index==0.0) position = (arrow-trans.xy)/trans.z ;
                    else if (index==1.0) position = (p0larrow2-trans.xy)/trans.z ; 
                    else position = (p0larrow-trans.xy)/trans.z ;  
                } 

                gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);  

            } else if (tidx== 0) { //각도때문에 첫 점은 특별하게

                //0번 점
                t = startPoint;
                tSquared = t * t;
                tCubed = tSquared * t;
                p0 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
        
                //1번 점
                t+=dt;
                tSquared = t * t;
                tCubed = tSquared * t;
                p1 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;

                vec2 p0p1 = p1-p0;
                vec2 p0p1Norm = normalize(p0p1);

                vec2 p0l = t* width * rotate(p0p1Norm, M_PI/2.0);  

                vec2 p0lf = p0 +p0l ;
                vec2 p0rf = p0 -p0l ;

                if (index==0.0) {
                    texValue =  vec2(11.0,0);
                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
								,1.0);
                    vec2 position = (p0lf-trans.xy)/trans.z ;          
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);   
                } else if (index==1.0) {
                    texValue =  vec2(11.0,0);
                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
								,1.0);
                    vec2 position = (p0rf-trans.xy)/trans.z ;          
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);   
                } else {

                    t+=dt;
                    tSquared = t * t;
                    tCubed = tSquared * t;
                    p2 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
            
                    v10 = normalize(p0-p1);
                    v12 = normalize(p2-p1);
                    float angle1 =getAngle(v12,v10); //두 직선이 이루는 각

                    p0l = calculatePL(v12, angle1, width, t, endPoint);       
                
                    p0lf = p1 +p0l ;
                    //p0rf = p1 -p0l ;

                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
                            ,1.0);
                    texValue =  vec2(11.0,0);
                    vec2 position = (p0lf-trans.xy)/trans.z ;          
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);  
                }
            




            } else if (tidx==1) { //각도때문에 두번째  점도 특별하게
                
                //0번 점
                t = startPoint;
                tSquared = t * t;
                tCubed = tSquared * t;
                p0 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
        
                //1번 점
                t+=dt;
                tSquared = t * t;
                tCubed = tSquared * t;
                p1 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;

                vec2 p0p1 = p1-p0;
                vec2 p0p1Norm = normalize(p0p1);

                vec2 p0l = t* width * rotate(p0p1Norm, M_PI/2.0);  

                vec2 p0lf = p0 +p0l ;
                vec2 p0rf = p0 -p0l ;

                if (index==0.0) {
                    texValue =  vec2(11.0,0);
                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
								,1.0);
                    vec2 position = (p0rf-trans.xy)/trans.z ;          
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);   
                    
                } else {

                    t+=dt;
                    tSquared = t * t;
                    tCubed = tSquared * t;
                    p2 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
            
                    v10 = normalize(p0-p1);
                    v12 = normalize(p2-p1);
                    float angle1 =getAngle(v12,v10); //두 직선이 이루는 각

                    p0l = calculatePL(v12, angle1, width, t, endPoint);        
                
                    p0lf = p1 +p0l ;
                    p0rf = p1 -p0l ;

                    vec2 position = index==1.0? (p0lf-trans.xy)/trans.z : (p0rf-trans.xy)/trans.z;
                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
                            ,1.0);
                    texValue =  vec2(11.0,0);
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);  
                    
                }
                
                
            } else if (tidx== int(tidx/2)*2) { //2,4,6...

                //-1번 점
                t = startPoint + float((tidx-2)/2) * dt;
                tSquared = t * t;
                tCubed = tSquared * t;
                p_1 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;


                //0번 점
                t+=dt;
                tSquared = t * t;
                tCubed = tSquared * t;
                p0 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
        
                //1번 점
                t+=dt;
                tSquared = t * t;
                tCubed = tSquared * t;
                p1 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;

                v10 = normalize(p_1-p0);
                v12 = normalize(p1-p0);
                float angle1 =getAngle(v12,v10); //두 직선이 이루는 각
                vec2 p0l = calculatePL(v12, angle1, width, t, endPoint);   

                vec2 p0lf = p0 +p0l ;
                vec2 p0rf = p0 -p0l ;

                if (index==0.0) {
                    texValue =  vec2(11.0,0);
                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
								,1.0);
                    vec2 position = (p0lf-trans.xy)/trans.z ;          
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);   
                } else if (index==1.0) {
                    texValue =  vec2(11.0,0);
                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
								,1.0);
                    vec2 position = (p0rf-trans.xy)/trans.z ;          
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);   
                } else {

                    t+=dt;
                    tSquared = t * t;
                    tCubed = tSquared * t;
                    p2 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
            
                    v10 = normalize(p0-p1);
                    v12 = normalize(p2-p1);
                    float angle1 =getAngle(v12,v10); //두 직선이 이루는 각

                    p0l =calculatePL(v12, angle1, width, t, endPoint);       
                
                    p0lf = p1 +p0l ;
                    //p0rf = p1 -p0l ;

                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
                            ,1.0);
                    texValue =  vec2(11.0,0);
                    vec2 position = (p0lf-trans.xy)/trans.z ;          
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);  
                }
            




            } else { //3, 5, 7, ...57

                //-1번 점
                t = startPoint + float((tidx-3)/2) * dt;
                tSquared = t * t;
                tCubed = tSquared * t;
                p_1 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;

                //0번 점
                t += dt;
                tSquared = t * t;
                tCubed = tSquared * t;
                p0 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
        
                //1번 점
                t+=dt; //58을 중심으로
                tSquared = t * t;
                tCubed = tSquared * t;
                p1 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;

                v10 = normalize(p_1-p0);
                v12 = normalize(p1-p0);
                float angle1 =getAngle(v12,v10); //두 직선이 이루는 각
                vec2 p0l = calculatePL(v12, angle1, width, t, endPoint);    


                vec2 p0lf = p0 +p0l ;
                vec2 p0rf = p0 -p0l ;

                if (index==0.0) {
                    texValue =  vec2(11.0,0);
                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
								,1.0);
                    vec2 position = (p0rf-trans.xy)/trans.z ;          
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);   
                    
                } else {

                    t+=dt;
                    tSquared = t * t;
                    tCubed = tSquared * t;
                    p2 = (aa* tCubed) + (bb* tSquared) + (cc * t) + ori;
            
                    v10 = normalize(p0-p1);
                    v12 = normalize(p2-p1);
                    float angle1 =getAngle(v12,v10); //두 직선이 이루는 각

                    p0l = calculatePL(v12, angle1, width, t, endPoint);     
                
                    p0lf = p1 +p0l ;
                    p0rf = p1 -p0l ;

                    vec2 position = index==1.0? (p0lf-trans.xy)/trans.z : (p0rf-trans.xy)/trans.z;
                    color = vec4(mix(colorOri.xyz,colorDes.xyz,t/endPoint)
                            ,1.0);
                    texValue =  vec2(11.0,0);
                    gl_Position =  vec4(position.x , position.y *trans.w, 0, 1.0);  
                    
                }
               


            }






      
            
        }
       

    </script>

    <script id="popumoveFragment" type="notjs">
  
        precision highp float;
        varying vec4 color;
        varying vec2 texValue;
        varying float isDiscard;

        void main() {

            if (isDiscard < 0.0) {
                discard;
            } else if (texValue.x>10.0) {
                gl_FragColor = vec4(color.xyz, 1.0);
            }
            else {
                float dotValue = dot(texValue,texValue);
                if (dotValue>1.0||dotValue<0.7) discard;
                else gl_FragColor = color;
            }
         
        }

    </script>


    <script id="mapBorderVertex" type="notjs">
        
        precision highp float;
        attribute vec2 pos;

        uniform vec4 trans;

        void main() {           
            vec2 position = (pos-trans.xy)/trans.z;          
            gl_Position =  vec4(position.x , position.y *trans.w, 0,1.0);        
        }
       

    </script>

    <script id="mapBorderFragment" type="notjs">
       
        precision highp float;
        uniform vec4 color;
        void main() {
            gl_FragColor = color;          
         
        }

    </script>
  
</head>
<body onload="main()">
    <div class="left_button">

        <div class='toggleBG1'>            
            <button id ='intraSido' class='toggleFG1' ></button>
            <txt class="toggleText">시도내 이동</txt>
        </div>
        <div class='toggleBG1'>            
            <button id ='interSido' class='toggleFG1' ></button>
            <txt class="toggleText">시도간 이동</txt>
        </div>
        <div class='spacer'></div>  

        <div class='toggleBG'>            
            <button id ='sido0' class='toggleFG' ></button>
            <txt class="toggleText">서울</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido1' class='toggleFG' ></button>
            <txt class="toggleText">부산</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido2' class='toggleFG' ></button>
            <txt class="toggleText">대구</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido3' class='toggleFG' ></button>
            <txt class="toggleText">인천</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido4' class='toggleFG' ></button>
            <txt class="toggleText">광주</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido5' class='toggleFG' ></button>
            <txt class="toggleText">대전</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido6' class='toggleFG' ></button>
            <txt class="toggleText">울산</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido7' class='toggleFG' ></button>
            <txt class="toggleText">세종</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido8' class='toggleFG' ></button>
            <txt class="toggleText">경기</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido9' class='toggleFG' ></button>
            <txt class="toggleText">강원</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido10' class='toggleFG' ></button>
            <txt class="toggleText">충북</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido11' class='toggleFG' ></button>
            <txt class="toggleText">충남</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido12' class='toggleFG' ></button>
            <txt class="toggleText">전북</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido13' class='toggleFG' ></button>
            <txt class="toggleText">전남</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido14' class='toggleFG' ></button>
            <txt class="toggleText">경북</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido15' class='toggleFG' ></button>
            <txt class="toggleText">경남</txt>
        </div>
        <div class='toggleBG'>
            <button id ='sido16' class='toggleFG' ></button>
            <txt class="toggleText">제주</txt>
        </div>

    
    </div>
    <div class="main_canvas">
        <canvas id="glcanvas"></canvas>    
        <canvas id="text"></canvas>
    </div>      
</body>
</html>


